#　workqueue　

## 基本常识

### １．workqueue　是运行在中断上下文，还是进程上下文中？其回调函数允许睡眠？

workqueue工作在**进程上下文**,既然工作在进程上下文中，那么在处理函数中一定是可以被允许睡眠的。**工作在中断上下文中的内核机制(具体忘了)是不被允许睡眠和耗时的操作的**

### ２．workqueue　和软中断和tasklet的异同点？

这里后期是需要额外进行对比学习的

工作队列机制是除了软中断和tasklet以外最常用的一种下半部机制。

工作队列的优点是利用进程上下文来执行中断下半部操作，因此工作队列允许重新调度和睡眠，是异步执行的进程上下文，另外它还能解决软中断和tasklet执行时间过长导致系统实时性下降的问题。**从这里我们就能得到一个启发，在实时性要求高的应用场景中，我们应该将不太要求实时性的工作，交给工作队列去处理，这样就能保证我们系统的实时性**

### ３．旧版的workqueue（linux 2.6.25）的机制在实际中遇到那些问题和挑战？

在早期的linux2.5.x　中内核引入了工作队列，早期设计时，由多线程和单线程组成。

多线程机制：multi　threaded，每个cpu默认一个工作线程。

单线程机制：single thread,用户可以自己创建工作线程(create_workqueue()函数)

在早期这种模式下,经过不断的测试发现了如下问题：

1. 内核线程数量太多(极易消耗系统pid资源)

这是因为单线程的机制导致的。由于很多驱动和子系统喜欢自己去创建工作队列，而不是用当前cpu的工作队列，这样在一些大型的多cpu系统来说，可能内核启动之后就消耗完了系统pid资源

2. 并发性比较差

这个是由多线程机制导致的。我们知道每个cpu都有自己的工作队列，cpu0的工作队列的任务，只能由cup0来做，不能由其他空闲cpu来帮忙处理。基于这一点，当cpu0有４个wrok时,如果wrok0睡眠了，那此时cpu0就被调度去执行其他进程了.那么此时就导致work1 work2 work3　没有执行的机会

3. 死锁问题

系统有一个默认的工作队列kevents，如果有很多work运行在默认的工作队列kevents上，并且他们有一些数据上依赖关系，那么很可能会产生死锁。解决方法就是为每一个有可能产生死锁的work创建一个专职的工作线程，这样就又回到第一个问题（极易消耗系统pid资源）。

### ４．ＣＭＷＱ机制如何动态管理工作线程池的线程呢？

### CMWQ是什么 concurrency-managed-workqueue(同时管理工作队列)

他是为解决之前linux2.5.x提出的workqueue的三个问题所诞生的。CMWQ是在linux2.6.36中提出的。

工作线程会串行化地执行挂入到队列中所有work。如果队列中没有work，那么该工作线程就会变成idle(闲)状态。为了管理众多工作线程，cmwq提出了工作线程池(worker-pool)概念。

### worker-pool 分类

1. BOUND类型

   每个cpu都有worker-pool

2. UNBOUND 类型

   worker-pool不和具体的cpu绑定

这两种worker-pool都会定义两个线程池，一个给普通优先级的work使用，另外一个给高优先级的work使用。

这些工作线程池的线程数量是动态分配和管理的，而不是固定的。当工作线程睡眠时，会去检查是否需要唤醒更多的工作线程，如果需要，会去唤醒同一个工作线程池中idle状态的工作线程。

### 在ＣＭＷＱ的机制改良下，新的工作队列运行的机制：

**系统中所有的工作队列，包括系统默认的工作队列，例如system_wq或system_highpri_wq等，以及驱动开发者新创建的工作队列，他们共享一组worker-pool(线程池)**

#### 对于ＢＯＵＮＤ类型的工作队列：

每个ＣＰＵ只有两个工作线程池（一个普通工作线程池，一个高优先级的工作线程池），每个工作线程池可以和多个workqueue对应，每个workqueue也只能对应这两个工作线程池。

也就是说，每个ＣＰＵ只有两个工作线程池，我们自己创建的　工作队列，也只能被这两个工作线程池中的idle(空闲)线程worker所执行。**这样依然会存在把一个ｃｐｕ忙死，把另外一个cpu闲死的情况吗？**

![](/home/colby/work/study/other/caobinxin.github.io/_posts/myntai_work/201809/2018-09-12-bound-unbound-workqueue.png)

### 5.如果有多个work挂入一个工作线程中执行，当某个work的回调函数执行阻塞操作，那么剩下的work该怎么办？



